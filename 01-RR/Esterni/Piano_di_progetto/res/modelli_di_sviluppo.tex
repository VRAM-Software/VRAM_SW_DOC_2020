\section{Modello di sviluppo}
Dall'analisi del progetto\glosp è stato identificato come modello di sviluppo più appropriato un modello di sviluppo incrementale. Tuttavia si è anche notato che, dato che sarà sviluppato un plugin, all'occorrenza sarà necessario utilizzare un modello di sviluppo a componenti in quanto, quando applicabile, faciliterà e velocizzerà notevolmente lo sviluppo tramite l'applicazione di:
\begin{itemize}
	\item \textbf{Component reuse}: riuso di componenti di un'applicazione esistente, siano essi sottosistemi o singoli oggetti che potranno essere utilizzati tramite opportune API;
	\item \textbf{Object and function reuse}: riuso di componenti software che realizzano una singola funzione o classe oggetto che potranno essere utilizzati come librerie durante lo sviluppo di nuovo codice sorgente.
\end{itemize}
Si è quindi ritenuto che il modello incrementale con utilizzo, dove opportuno, di modello a componenti sia la soluzione migliore per realizzare il prodotto\glosp richiesto, in quanto permetterà di agevolare e strutturare in modo efficace ed efficiente lo sviluppo, portando continuamente valore aggiunto al prodotto\glosp e velocizzando lo sviluppo tramite il riuso di componenti esistenti.

\subsection{Modello incrementale}
Il modello di sviluppo incrementale rappresenta il principale modello di sviluppo che sarà utilizzato per sviluppare il plugin, in quanto la sua natura ad incrementi porterà i seguenti vantaggi:
\begin{itemize}
	\item Agevolazione dell'organizzazione dello sviluppo, in quanto ci sarà corrispondenza fra requisiti ed incrementi;
	\item Agevolazione della verifica in quanto potrà essere effettuata ad ogni incremento senza dover necessariamente bloccare lo sviluppo degli altri incrementi;
	\item Agevolazione del monitoraggio dei progressi, in quanto ogni incremento porterà valore aggiunto al prodotto\glo.
\end{itemize}
La prima attività del modello di sviluppo incrementale consiste nell'individuazione dei requisiti da implementare, che vanno classificati in base alla loro rilevanza per gli stakeholder\glo. È così possibile sviluppare per primi i requisiti ad importanza critica che rappresentano le funzionalità cardine del prodotto\glo, lasciando in secondo piano i requisiti non prioritari, facendo corrispondere appunto ad ogni incremento uno o più requisiti.
Il metodo di lavoro incrementale è quindi così riassunto:
\begin{itemize}
	\item Individuare i requisiti del prodotto\glo;
	\item Definire degli incrementi facendo loro corrispondere uno o più requisiti;
	\item Analizzare se negli incrementi è possibile riutilizzare componenti secondo il modello di sviluppo a componenti;
	\item I seguenti passaggi saranno eseguiti per ogni incremento:
	\begin{itemize}
		\item Suddivisione dello sviluppo del singolo incremento fra gli sviluppatori;
		\item Sviluppo del singolo incremento;
		\item Verifica dello sviluppo da parte dei verificatori;
		\item Validazione\glosp dell'incremento tramite riunione di gruppo, in cui si verifica se l'incremento soddisfa effettivamente i requisiti a lui assegnati;
		\item Discussione ed eventuale attuazione di miglioramenti per i prossimi incrementi.
	\end{itemize}
\end{itemize}

\subsubsection{Incrementi individuati}
La seguente tabella riporta i principali incrementi individuati e definiti inizialmente. La priorità è data agli incrementi che implementano requisiti obbligatori, seguiti dagli incrementi riguardanti requisiti desiderabili ed infine sono riportati degli incrementi che potrebbero implementare i requisiti opzionali.
\rowcolors{2}{gray!25}{gray!15}
\begin{longtable} {
		>{\raggedright\arraybackslash}p{85mm}
		>{\raggedleft\arraybackslash}p{40mm}
	}
	\rowcolor{gray!50} 
	\textbf{Incremento} & 
	\textbf{Requisiti} 	\TBstrut \\
	
	Incremento 1: creazione struttura base applicativo addestramento &
	R1F2.3  \TBstrut \\ [2mm]		
	
	Incremento 2: importazione file JSON su applicativo esterno & 
	R1F2, R1F2.1  \TBstrut \\ [2mm]
	
	Incremento 3: sviluppo algoritmo addestramento SVM\glosp & 
	R1F2.2  \TBstrut \\ [2mm]
	
	Incremento 4: sviluppo algoritmo addestramento RL\glosp & 
	R1F2.2  \TBstrut \\ [2mm]
	
	Incremento 5: Selezione algoritmo di addestramento & 
	R1F2.2  \TBstrut \\ [2mm]
	
	Incremento 6: avvio addestramento & 
	R1F2.3, R1F2.4 \TBstrut \\ [2mm]
	
	Incremento 7: creazione file JSON con i parametri addestramento &
	R1F2.5 \TBstrut \\ [2mm]
	
	Incremento 8: esportazione file JSON con i parametri addestramento &
	R1F2.5 \TBstrut \\ [2mm]
	
	Incremento 9: realizzazione struttura base plugin Grafana\glosp &
	R1F13, R1F13.1, R1F13.2, R1F13.3 \TBstrut \\ [2mm]
	
	Incremento 10: importazione file JSON nel plugin &
	R1F13, R1F13.1, R1F13.2, R1F13.3 \TBstrut \\ [2mm]
	
	Incremento 11: sviluppo algoritmo predizione SVM\glosp nel plugin &
	R1F13, R1F13.1, R1F13.2, R1F13.3 \TBstrut \\ [2mm]
	
	Incremento 12: sviluppo algoritmo predizione RL\glosp nel plugin &
	R1F13, R1F13.1, R1F13.2, R1F13.3 \TBstrut \\ [2mm]
	
	Incremento 13: lettura file JSON e configurazione algoritmi plugin &
	R1F13, R1F13.1, R1F13.2, R1F13.3 \TBstrut \\ [2mm]
	
	Incremento 14: selezione algoritmo di predizione nel plugin &
	R1F13, R1F8.2.2 \TBstrut \\ [2mm]
	
	Incremento 15: avvio algoritmo di predizione &
	R1F13, R1F13.1, R1F13.2, R1F13.3 \TBstrut \\ [2mm]
	
	Incremento 16: predisposizione dati ottenuti dagli algoritmi per la visualizzazione &
	R1F13, R1F13.1, R1F13.2, R1F13.3 \TBstrut \\ [2mm]
	
	Incremento 17: visualizzazione dei dati &
	R1F13, R1F8 \TBstrut \\ [2mm]
	
	Incremento 18: modifica algoritmo predizione nel plugin &
	R1F9.1.2 \TBstrut \\ [2mm]
	
	Incremento 19: eliminazione visualizzazione dei dati &
	R1F12 \TBstrut \\ [2mm]
	
	Incremento 20: modifica visualizzazione dei dati &
	R1F9.2.1 \TBstrut \\ [2mm]
	
	Incremento 21: visualizzazione bontà predizione dati &
	R1F14 \TBstrut \\ [2mm]
	
	Incremento 22: visualizzazione errore file JSON addestramento &
	R2F3 \TBstrut \\ [2mm]
	
	Incremento 23: visualizzazione errore configurazione data source &
	R2F5, R2F6 \TBstrut \\ [2mm]
	
	Incremento 24: visualizzazione errori configurazione grafici &
	R2F10, R2F11 \TBstrut \\ [2mm]
	
	Incremento 25: conversione dell'addestramento esterno in addestramento interno a Grafana\glosp &
	R3F1, R3F1.1, R3F1.2, R3F1.3, R3F1.4 \TBstrut \\ [2mm]
	
	Incremento 26: sviluppo algoritmo regressione non lineare &
	R3F3.1 \TBstrut \\ [2mm]
	
	Incremento 27: sviluppo algoritmo reti neurali &
	R3F3.1 \TBstrut \\ [2mm]
	
\end{longtable}

\subsection{Modello a componenti}
Per la realizzazione del prodotto\glosp sarà anche utilizzato, quando possibile, il modello di sviluppo a componenti, così da velocizzare e standardizzare lo sviluppo dei requisti.
I componenti evidenziati dall'analisi sono principalmente gli elementi esistenti di Grafana\glosp e gli algoritmi di predittività forniti da \textit{Zucchetti}.
In particolare tali elementi vengono inquadrati nelle seguenti classi di componenti:
\begin{itemize}
	\item \textbf{Elementi Grafana}\glo: Sono le librerie  e le funzionalità fornite da Grafana\glo, il loro uso viene quindi inquadrato come component reuse;
	\item \textbf{Algoritmi di predittività}: Sono gli algoritmi che ci sono stati forniti da \textit{Zucchetti} e saranno riutilizzabili come librerie durante lo sviluppo del plugin, il loro uso viene quindi inquadrato come object and function reuse.
\end{itemize}
