\subsection{Verifica}
\subsubsection{Scopo}
La verifica ha lo scopo di accertare che i risultati ottenuti da tutte le attività, attuate in un periodo preso in considerazione, raggiungano tutti i requisiti richiesti senza aver introdotto degli errori. La verifica deve essere svolta durante il ciclo di vita del software, più precisamente al passare di ogni baseline\glo.
\subsubsection{Aspettative}
La verifica viene effettuata per raggiungere i seguenti obiettivi:
\begin{itemize}
	\item Cercare consistenza, completezza e correttezza nelle singole attività;
	\item Ottenere supporto per una successiva validazione del prodotto;
	\item Avere a disposizione dei criteri e procedure, comprensibili e affidabili, da seguire.
\end{itemize}
\subsubsection{Descrizione}
Il processo di verifica assicura che tutte le attività svolte della fase in esame, attraverso analisi e test successivamente definiti, siano conformi alle aspettative.
\subsubsection{Attività}
\paragraph{Analisi}\mbox{}\\ [1mm]
Le attività che si effettuano durante la verifica sono due tipi di analisi: l'analisi statica\glosp e l'analisi dinamica. \\[2mm]
\textbf{Analisi statica}\mbox{}\\ [1mm]
L'analisi statica\glosp è lo studio della documentazione e del codice sorgente, essa non richiede l'esecuzione delle singole parti del sistema software che si sta sviluppando, quindi viene applicata ad ogni prodotto di processo. L'analisi statica\glosp può essere effettuata manualmente in due modi:
\begin{itemize}
	\item \textbf{Walkthrough} \\*
	Metodo di lettura in cui tutti i componenti del gruppo analizzano tutti i documenti e codice realizzato, senza tralasciare nulla, in modo da rilevare eventuali errori. Questa ricerca è ad ampio spettro, infatti viene effettuata anche se a priori non si può sapere se verranno trovate anomalie;
	\item \textbf{Inspection} \\*
	Metodo di lettura o desk check per cercare errori specifici utilizzando liste di controllo o check list, la tabella successiva rappresenta gli errori che i nostri verificatori hanno identificato come essere i più frequenti.
\end{itemize}
\rowcolors{2}{gray!25}{gray!15}
\renewcommand\thetable{3.1}
\begin{longtable} {
		>{\centering}p{55mm} 
		>{\centering}p{55mm}
		>{}p{0mm}}
	\rowcolor{gray!50}
	\textbf{Oggetto da controllare} & \textbf{Correzione} & \TBstrut \\[2mm]
	Formato data dei documenti & Tutte le date devono utilizzare la seguente scrittura: \textit{YYYY-MM-DD}  &  \TBstrut \\[2mm]
	Sintassi nome documenti citati & I documenti, interni o esterni, citati nella documentazione devono essere scritti in italico utilizzando il comando: \verb|\textit{}|  &  \TBstrut \\[2mm]
	Sintassi parole da enfatizzare & Le parole da enfatizzare, come titolo di liste puntate, devono essere scritte i grassetto utilizzando il comando: \verb|\textbf{}|  &  \TBstrut \\[2mm]
	Punteggiatura liste puntate & Ogni elemento nelle liste puntate deve iniziare con una lettera maiuscola e deve finire con un punto e virgola &  \TBstrut \\[2mm]
	Uso corretto dei comandi \verb|\glo| e \verb|\glosp| & I comandi \verb|\glo| e \verb|\glosp|, sono stati creati per identificare le parole da inserire nel glossario, \verb|\glo| dovrà essere usato se la parola del glossario precede un carattere di punteggiatura. Il comando \verb|\glosp| sarà invece usato per le parole che precedono uno spazio &  \TBstrut \\	[2mm]
	\rowcolor{white}
	\caption{Tabella errori più frequenti}
\end{longtable}

\textbf{Analisi dinamica} \\ [1mm]
L'analisi dinamica è una tecnica che consiste nell'esecuzione del prodotto software eseguendo dei test su un insieme finito di casi.
\paragraph{Test}\mbox{}\\ [1mm]
Per la corretta verifica del codice, i test devono seguire regole ben precise che definiscono i parametri e le proprietà che devono avere test per essere considerati efficaci: \\*
\textbf{Parametri da definire}:
\begin{itemize}
	\item \textbf{Input}: l'input preso in considerazione;
	\item \textbf{Output}: l'output che si aspetta di ricevere;
	\item \textbf{Ambiente}: l'ambiente, quindi hardware e sistema operativo, in cui viene eseguito il test;
	\item \textbf{Stato iniziale}: lo stato iniziale del prodotto, precedente all'esecuzione del test;
	\item \textbf{Istruzioni opzionali}: l'utilizzo di istruzioni opzionali aggiuntive deve essere noto.
\end{itemize} 
\textbf{Un test può essere definito efficace se}:
\begin{itemize}
	\item I parametri citati sopra sono correttamente indicati;
	\item Il nome di un test deve essere autoesplicativo per capire subito che cosa si sta testando;
	\item Esso è ripetibile, quindi ci si aspetta un risultato costante per tutte le esecuzioni di quel test;
	\item In caso di fallimento del test, esso devo fornire informazioni utili a risolvere il problema identificato;
	\item In caso di possibili effetti indesiderati ci si aspetta un avvertimento;
	\item Esso è esaustivo e accurato, infatti devono poter identificare una parte del progetto che potrebbe essere causa di errori.
\end{itemize}
Il cosiddetto software testing è un procedimento importante per misurare la qualità di un prodotto software, per questo motivo sono definiti cinque livelli che dividono i tipi di test da effettuare secondo una gerarchia. Essi sono: 
\begin{itemize}
	\item \textbf{Test d'unità};
	\item \textbf{Test d'integrazione};
	\item \textbf{Test di sistema};
	\item \textbf{Test di accettazione}.
\end{itemize}

\textbf{Test d'unità} \\*
I test d'unità si definiscono tali perché controllano il corretto funzionamento di una sezione di codice specifica chiamata unità. Usualmente questi tipi di test vengono eseguiti su funzioni o, se si parla di programmazione ad oggetti, su un metodo di una classe, quindi su una parte minimale del codice. Il loro scopo è verificare che gli input forniti diano gli output attesi. È buona norma rendere questi test automatici per minimizzare il tempo di esecuzione senza richiedere l'interazione dello sviluppatore. Questo tipo di test viene scritto dal programmatore che sviluppa le singole unità mediate l'ausilio di driver\glosp e stub\glo, per verificare l'assenza di errori e documentare il funzionamento dell'unità. \\*

\textbf{Test d'integrazione} \\*
Successivamente ai test d'unità, si assemblano gruppi di unità progressivamente che formeranno degli agglomerati sempre più grandi. Questo tipo di test, infatti, si concentra nella ricerca di anomalie ed errori tra le interfacce dei singoli componenti. Una volta concluso un singolo test, si otterrà un agglomerato che costituirà una nuova unità da cui partire per ulteriori test d'integrazione. Per svolgere questo test si è scelto un approccio iterativo. \\*

\textbf{Test di sistema} \\*
I test di sistema controllano il funzionamento corretto del prodotto e verificano che il sistema soddisfi tutti i requisiti definiti nel documento: \textit{Analisi dei Requisiti}. Con l'esecuzione di questi test si riesce a definire e documentare tutte le funzionalità del sistema e possono individuare criticità come il problema del black-box\glo. Il gruppo svolgerà questo test quando si raggiungerà uno stato di rilascio per il prodotto sviluppato.
Per identificare un test di unità viene utilizzata una codifica con il seguente formato:
\textbf{TS[codice]}
Dove codice è un numero progressivo nel formato: [X].[Y] con X e Y numeri maggiori di zero.\\*

\textbf{Test di accettazione} \\*
I test di accettazione, o di collaudo, vengono effettuati ad ogni pre-rilascio, quindi dopo l'esecuzione dei test di sistema. Essi servono a confermare il soddisfacimento dei requisiti da parte del committente; infatti questi tipi di test ne richiedono la presenza. Se questi test vengono superati significa che il prodotto software è pronto per il rilascio. 
Per identificare un test di accettazione viene utilizzata una codifica con il seguente formato:
\textbf{TA[codice]}
Dove codice è un numero progressivo nel formato: [X].[Y] con X e Y numeri maggiori di zero.\\*

\subsubsection{Strumenti}
	\paragraph{Correzione ortografica}\mbox{}\\ [1mm]
	Il nostro gruppo ha utilizzato, per la ricerca di errori ortografici o stilistici nel testo dei documenti, la libreria HunSpell utilizzata con l'editor di test: TexStudio. Esso permette di avere un controllo in tempo reale su errori ortografici in lingua inglese e italiana (sottolineati in rosso) e ripetizioni di parole a breve distanza (sottolineati in verde).
